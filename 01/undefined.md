# 스프링 부트의 주요 특징

톰캣, 제티, 언더토우 같은 웹 애플리케이션 서버가 내장되어 있어서 따로 설치를 하지 않아도 독립적으로 실행할 수 있습니다.

빌드 구성을 단순화하는 스프링 부트 스타터를 제공합니다.

XML 설정을 하지 않고 자바 코드로 모두 작성 할 수 있습니다.

JAR 를 이용해서 자바 옵션만으로도 배포가 가능하다.

애플리케이션의 모니터링 및 관리 도구인 스프링 액츄에이터를 제공합니다.



## 스프링과 스프링 부트의 차이점

스프링은 애플리케이션 개발에 필요한 환경을 수동으로 구성하고 정의해야 한다.

하지만 스프링 부트는 스프링 코어와 스프링 MVC의 모든 기능을 자동으로 로드하므로 수동으로 개발 환경을 구성할 피요가 없습니다.



## 내장 WAS 의 유무

스프링 부트는 WAS를 자체적으로 가지고 있습니다.

그래서 jar 파일만 만들면 별도로 WAS 를 설정하지 않아도 애플리케이션을 실행할 수 있습니다. 참고로 스프링 부트의 내장 WAS 에는 톰캣, 제티, 언더토우가 있어서 상황에 필요한 WAS 를 선택할 수도 있습니다.

왼쪽이 스프링 오른쪽이 스프링 부트이다.

<figure><img src="../.gitbook/assets/스크린샷 2023-12-06 오후 11.33.45.png" alt=""><figcaption></figcaption></figure>

## 제어의 역전과 의존성 주입

만약 객체를 생성하려면&#x20;

```java
public class A {
    b = new B();
}
```

이렇게 인스턴스 생성을 해줘야한다.

제어의 역전은 다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것을 말한다.

실제로 스프링은 스프링 컨테이너가 객체를 관리, 제공하는 역할을 합니다.

그래서 다음과 같이 코드가 변경됩니다.

```java
public class A {
    private B b;
    // 코드에서 객체를 생성하지 않음.
    // 어디선가 받아온 객체를 b에 할당
}
```



## DI 란?

DI 는 어떤 클래스가 다른 클래스에 의존한다는 뜻이다.

@Autowired 라는 애너테이션은 스프링 컨테이너에 있는 빈이라는 것을 주입하는 역할을 합니다.

빈은 쉽게 말해 스프링 컨테이너에서 관리하는 객체를 말합니다.

빈은 바로 다음에 설명할 개념이므로 우선은 이 정도만 이해하고 넘어가도 됩니다.

이전 코드에서는 개발자가 직접 B 객체를 생성했지만 다음 코드는 어딘가에서 B b; 라고 선언했을 뿐 직접 객체를 생성하지는 않고 있습니다.

다시 말해 객체를 주입받고 있다.

```java
public class A {
    // A 에서 B를 주입받음
    @Autowired
    B b;
}
```

코드가 잘 실행이 되는데 , 그 이유는 스프링 컨테이너라는 곳에서 객체를 주입했기 때문입니다. 쉽게 말해 스프링 컨테이너가 B 객체를 만들어서 클래스 A 에 준 겁니다.

<figure><img src="../.gitbook/assets/스크린샷 2023-12-06 오후 11.50.19.png" alt=""><figcaption></figcaption></figure>

기존의 자바 코드는 클래스 A 에서 B 객체를 직접 생성지만,

스프링의 경우 클래스 A 에서 B 객체를 쓰고 싶은 경우 스프링 컨테이너에서 객체를 주입받아 사용합니다.



## 빈과 스프링 컨테이너

스프링 컨테이너란?

앞서 언급했던 것처럼 스프링은 스프링 컨테이너를 제공합니다. 스프링 컨테이너는 앞서 본 것처럼 빈을 생성하고 관리합니다. 즉 빈이 생성되고 소멸되기까지의 생명주기를 이 스프링 컨테이너가 관리하는 것이죠.

개발자가 @Autowired 같은 애너테이션을 사용해 빈을 주입받을 수 있게 DI 를 지원하기도 합니다.



### 빈이란 ?

빈은 스프링 컨테이너가 생성하고 관리하는 객체입니다.

앞에서 본 코드에서 B 가 바로 빈인데요 .

스프링은 빈을 스프링 컨테이너에 등록하기 위해 XML 파일 설정, 애너테이션 추가 등의 방법을 제공한다.



## 스프링 부트 스타터

스프링 부트 스타터는 의존성이 모여 있는 그룹이다.

<figure><img src="../.gitbook/assets/스크린샷 2023-12-07 오후 5.18.59.png" alt=""><figcaption></figcaption></figure>

스프링 부트 스타터(Starters)는 스프링 부트 애플리케이션을 빠르고 쉽게 개발할 수 있도록 도와주는 의존성 모음입니다. 스타터는 일반적으로 필요한 라이브러리들을 묶어서 제공하며, 개발자는 이를 통해 필요한 의존성을 간편하게 추가할 수 있습니다.

스프링 부트 스타터의 주요 특징은 다음과 같습니다:

1. **간편한 의존성 관리**: 스타터를 사용하면 관련된 여러 의존성을 개별적으로 추가할 필요 없이, 하나의 스타터 의존성으로 관리할 수 있습니다. 이는 의존성 관리를 단순화시킵니다.
2. **자동 구성(Auto-configuration)**: 스프링 부트는 클래스패스에 있는 라이브러리를 기반으로 애플리케이션을 자동으로 구성합니다. 예를 들어, 스프링 웹 스타터를 추가하면 스프링 MVC와 관련된 설정이 자동으로 이루어집니다.
3. **프로젝트 표준화**: 스타터를 사용하면 프로젝트의 구조와 의존성이 일관되게 유지됩니다. 이는 팀 내에서 프로젝트의 일관성을 유지하는 데 도움이 됩니다.
4. **빠른 프로토타이핑**: 스타터를 사용하면 필요한 의존성을 빠르게 추가하고, 애플리케이션 개발에 집중할 수 있어 프로토타이핑 속도가 빨라집니다.

스프링 부트 스타터의 예시:

* `spring-boot-starter-web`: 스프링 MVC와 톰캣을 포함한 웹 애플리케이션 개발을 위한 스타터.
* `spring-boot-starter-data-jpa`: 스프링 데이터 JPA와 관련된 의존성을 포함한 스타터.
* `spring-boot-starter-security`: 스프링 시큐리티를 사용한 보안 관련 기능을 위한 스타터.
* `spring-boot-starter-test`: 테스트를 위한 스프링 부트 테스트 프레임워크와 관련된 의존성을 포함한 스타터.

스타터를 사용함으로써 개발자는 의존성 관리와 구성에 드는 시간과 노력을 줄이고, 애플리케이션 개발에 더 집중할 수 있습니다.



## 스프링 부트3와 자바 버전

스프링 부트 3이전과 이후는 사용할 수 있는 자바 버전 범위가 다릅니다.

스프링부트 3은 자바 17버전 이상을 사용해야 합니다.

### 자바 코드

formatted() 메서드

```java
String textBlock17 = """
{
    "id": %d
    "name":%s,
}
""".formatted(2,"juice");
```

레코드

레코드는 상속을 할 수 없고, 파라미터에 정의한 필드는 private final 로 정의됩니다.

또한 레코드는 getter 를 자동으로 만들기 때문에 애너테이션이나 메서드로 게터 정의하지 않아도 된다.

```java
record Item(String name, int price) {

}

Item juice = new Item("juice", 3000);
juice.price(); // 3000
```



패턴매칭

<figure><img src="../.gitbook/assets/스크린샷 2023-12-07 오후 5.31.42.png" alt=""><figcaption></figcaption></figure>

이전에는 instanceof 를 사용하고 난뒤에 형변환을 해야하는데&#x20;

이제는 바로 형변환을 한다음 사용할 수 있습니다.

자료형에 맞는 case 처리

switch-case 문 으로 자료형에 맞게 case 처리를 할 수도 있습니다.



```java
static double getIntegerValue(Object o) {
    return switch(o) {
        case Double d -> d.intValue();
        case Float f -> f.intValue();
        case String s -> Integer.parseInt(s);
        default -> 0d;
    };
}
```



Servlet, JPA의 네임 스페이스가 Jakarta로 대체됐다.

패키지 네임스페이스가 javax.\* 에서 jakarta.\* 로 변경되었습니다.

변경한 이유가 뭘까??

`javax.*`에서 `jakarta.*`로의 네임스페이스 변경은 Java EE (Enterprise Edition)에서 Jakarta EE로의 전환의 일부입니다. 이 변경의 배경을 이해하려면 Java EE의 역사와 이것이 어떻게 Jakarta EE가 되었는지를 살펴볼 필요가 있습니다.

#### Java EE의 역사와 Jakarta EE로의 전환

1. **Java EE의 시작**: Java EE는 원래 Sun Microsystems에 의해 개발되었으며, 엔터프라이즈급 Java 애플리케이션을 개발하기 위한 표준 사양으로 사용되었습니다.
2. **오라클의 인수**: Sun Microsystems가 오라클에 인수된 후, Java EE도 오라클의 관리 하에 들어갔습니다.
3. **커뮤니티의 우려**: 시간이 지남에 따라 Java EE에 대한 오라클의 관리와 개발 속도에 대한 커뮤니티의 우려가 커졌습니다. 많은 개발자와 조직들이 Java EE의 미래에 대해 우려를 표명했습니다.
4. **오라클에서 이클립스 재단으로의 이전**: 이러한 우려에 대응하여, 오라클은 Java EE의 관리와 개발을 오픈 소스 재단인 이클립스 재단에 이전하기로 결정했습니다. 이것이 Jakarta EE의 시작이었습니다.

#### 네임스페이스 변경의 이유

* **법적 문제**: 오라클은 `javax.*` 네임스페이스에 대한 상표권을 보유하고 있었습니다. 이클립스 재단이 Java EE를 인수하면서, 오라클의 상표권에 대한 문제가 발생했습니다. 이로 인해 새로운 네임스페이스가 필요했습니다.
* **새로운 시작**: `jakarta.*` 네임스페이스로의 전환은 Jakarta EE가 Java EE의 단순한 연속이 아니라, 새로운 시작을 의미합니다. 이는 커뮤니티 주도의 개발과 혁신을 강조하는 새로운 시대의 시작을 상징합니다.
* **호환성 문제**: 기존 `javax.*` 네임스페이스를 사용하는 애플리케이션과 라이브러리는 Jakarta EE로 전환하는 과정에서 호환성 문제에 직면할 수 있습니다. 이는 개발자들이 이러한 변화를 고려하여 애플리케이션을 업데이트하거나 마이그레이션해야 함을 의미합니다.

#### 결론

`javax.*`에서 `jakarta.*`로의 네임스페이스 변경은 Java EE에서 Jakarta EE로의 전환의 일환으로, 법적 문제, 새로운 시작의 상징, 그리고 커뮤니티 주도의 개발과 혁신을 강조하기 위한 결정이었습니다. 이 변경은 Java 기반 엔터프라이즈 애플리케이션 개발의 미래에 중요한 영향을 미치고 있습니다.



@SpringBootConfiguration&#x20;

스프링 부트 관련 설정을 나타내는 애너테이션입니다.

스프링을 아는 독자라면 @Configuration 을 상속해서 만든 애너테이션입니다.

이 애너테이션은 개발자가 직접 사용하는 애너테이션은 아닙니다



@EnableAutoConfiguration&#x20;

스프링 부트에서 자동 구성을 활성화하는 애너테이션입니다.

이 애너테이션은 스프링 부트 서버가 실행될 때 스프링 부트의 메타 파일을 읽고 정의된 설정들을 자동으로 구성하는 역할을 수행합니다.



## 스프링 부트 요청-응답 과정 이해하기.

스프링 부트로 만든 애플리케이션에서 HTTP 요청이 오면 어떤 과정을 거치며 실행되고 응답하는지 알아봅니다.

<figure><img src="../.gitbook/assets/스크린샷 2023-12-08 오후 9.31.16.png" alt=""><figcaption></figcaption></figure>

스프링 부트의 디스패처 서블릿이라는 녀석이 URL을 분석하고, 이 요청을 처리할 수 있는 컨트롤러를 찾습니다.

TestController 가 /test 라는 패스에 대한 GET 요청을 처리할 수 있는 getAllMembers() 메서드를 가지고 있으므로 디스패처 서블릿은 TestController 에게 /test GET 요청을 전달합니다.

마침내 /test /GET 요청을 처리할 수 있는 getAllMembers() 메서드와 이 요청이 매치됩니다.

그리고 getAllMembers() 메서드에서는 비즈니스 계층과 퍼시스턴스 계층을 통하면서 필요한 데이터를 가져옵니다.



* 프레젠테이션 계층 : HTTP 요청을 받고 비즈니스 계층을 전송합니다.
* 비즈니스 계층은 모든 비즈니스 로직을 처리합니다. 퍼시스턴스 계층에서 제공하는 서비스를 사용할 수도 있고, 권한을 부여하거나 유효성 검사를 하기도 합니다.
* 퍼시스턴스 계층은 모든 스토리지 관련 로직을 처리합니다. 이 과정에서  데이터베이스에 접근하기 위한 객체인 DAO를 사용할 수도 있습니다.

