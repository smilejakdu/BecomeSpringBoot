# 05 ORM

* JPA : 자바 객체와 데이터베이스를 연결해 데이터를 관리합니다. 객체 지향 도메인 모델과 데이터베이스의 다리 역할을 합니다.
* 하이버네이트: JPA의 인터페이스를 구현합니다. 내부적으로는 JDBC API 를 사용합니다.

<figure><img src=".gitbook/assets/스크린샷 2023-12-09 오후 6.02.23.png" alt=""><figcaption></figcaption></figure>

스프링 부트는 기본적으로 빈을 하나만 생성해서 공유하므로 동시성 문제가 발생할 수 있습니다.

그래서 실제로는 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시(가짜) 엔티티 매니저를 사용합니다.

필요할 때 데이터베이스 트랜잭션과 관련된 실제 엔티티 매니저를 호출하는 겁니다.



## 영속성 컨텍스트란 ?

영속성 컨텍스트는 JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간입니다.

이것이 있기 때문에 데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있습니다.

영속성 컨텍스트는 왜 알아야할까요 ??

영속성 컨텍스트(Persistence Context)를 이해하는 것은 여러 가지 이유로 중요합니다. 주로 데이터베이스와 객체 지향 프로그래밍 언어 간의 상호작용을 다루는 영역에서 중요한 개념입니다. 영속성 컨텍스트의 이해는 다음과 같은 이점을 제공합니다:

1. **데이터 캐싱**: 영속성 컨텍스트는 일종의 캐시로 작동하여, 데이터베이스에 대한 반복적인 쿼리를 줄일 수 있습니다. 이는 애플리케이션의 성능 향상에 기여합니다.
2. **데이터 동기화 관리**: 영속성 컨텍스트는 객체와 데이터베이스 사이의 동기화를 관리합니다. 이를 통해 개발자는 데이터 동기화에 대한 걱정 없이 비즈니스 로직에 집중할 수 있습니다.
3. **트랜잭션 지원**: 영속성 컨텍스트는 트랜잭션 관리를 쉽게 만들어 줍니다. 트랜잭션 내에서 발생하는 변경사항은 트랜잭션이 커밋될 때 한꺼번에 데이터베이스에 반영됩니다.
4. **일관된 데이터 무결성**: 영속성 컨텍스트는 객체 간의 관계를 관리하고, 데이터 무결성을 유지하는 데 도움을 줍니다.
5. **자동 페치와 지연 로딩**: 영속성 컨텍스트는 필요할 때 자동으로 관련 데이터를 로딩하거나 지연 로딩을 지원합니다. 이는 애플리케이션의 성능과 메모리 사용 효율성을 향상시킵니다.

영속성 컨텍스트의 이해는 특히 Java의 JPA(Java Persistence API)나 Hibernate 같은 ORM(Object-Relational Mapping) 프레임워크를 사용할 때 중요합니다. 이러한 프레임워크는 객체와 관계형 데이터베이스 간의 간격을 메우는 데 도움을 주며, 영속성 컨텍스트는 이러한 상호작용의 핵심적인 부분입니다.



### 1차 캐시

영속성 컨텍스트는 내부에 1차 캐시를 가지고 있습니다.

엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환합니다.

값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환합니다.

이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터를 조회할 수 있습니다.



### 쓰기 지연

쓰기 지연은 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미한다.



쓰기 지연(Write-Behind or Deferred Write)은 영속성 컨텍스트에서 중요한 개념으로, 데이터베이스와의 상호작용을 최적화하는 데 사용됩니다. 이 기능은 데이터베이스 트랜잭션의 성능을 향상시키는 데 도움을 주며, 주로 JPA나 Hibernate와 같은 ORM(Object-Relational Mapping) 프레임워크에서 찾아볼 수 있습니다.

쓰기 지연의 기본 원리와 이점은 다음과 같습니다:

1. **변경 데이터의 일시적 저장**: 개발자가 객체의 상태를 변경할 때, 이 변경사항은 즉시 데이터베이스에 반영되지 않습니다. 대신, 영속성 컨텍스트 내부의 쓰기 지연 SQL 저장소에 이러한 변경사항이 SQL 형태로 저장됩니다.
2. **트랜잭션의 최적화**: 쓰기 지연은 트랜잭션 내에서 여러 변경사항을 수집하고, 트랜잭션이 커밋될 때 한 번에 데이터베이스로 전송합니다. 이를 통해 네트워크 사용과 데이터베이스에 대한 부하를 줄이며, 전체적인 트랜잭션 성능을 향상시킵니다.
3. **커밋 시의 일괄 처리**: 트랜잭션이 커밋되는 시점에 쓰기 지연 저장소에 있는 모든 SQL 명령이 데이터베이스로 전송됩니다. 이 일괄 처리 방식은 특히 많은 수의 작은 변경사항이 있는 경우에 효율적입니다.
4. **자원 사용의 효율성**: 쓰기 지연을 통해 데이터베이스 연결 시간과 자원 사용을 최적화할 수 있습니다. 이는 애플리케이션의 전반적인 성능에 긍정적인 영향을 미칩니다.
5. **트랜잭션 관리의 간소화**: 개발자는 트랜잭션의 끝에서만 데이터베이스와의 상호작용을 신경 쓰면 되므로, 트랜잭션 관리가 더 간단해집니다.

쓰기 지연은 특히 대량의 데이터를 다룰 때 또는 복잡한 트랜잭션이 많은 애플리케이션에서 그 효용이 두드러집니다. 하지만, 모든 상황에서 유리한 것은 아니며, 트랜잭션의 크기나 네트워크 환경 등에 따라 그 효과가 달라질 수 있습니다.



예를들어 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜잭션을 커밋하는 시점에 3개의 쿼리를 한꺼번에 쿼리를 전송합니다.

이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있습니다.

### 변경 감지

트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영합니다.

이를 통해 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, 데이터베이스 시스템의 부담을 줄일 수 있습니다.



### 지연 로딩

지연 로딩은 쿼리로 요청한 데이터를 application 에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미합니다.



### 엔티티의 상태

엔티티는 4가지 상태를 가집니다.

영속성 컨텍스트가 관리하고 있지 않은 분리상태, 영속성 컨텍스트가 관리하는 관리상태, 영속성 컨텍스트와 전혀 관계가 없는 비영속 상태, 삭제된 상태로 나눠집니다.

이 상태는 특정 메서드를 호출해 변경할 수 있는데요.

필요에 따라 엔티티의 상태를 조절해 데이터를 올바르게 유지하고 관리할 수  있습니다.



```java
public class EntityManagerTest {
    
    @Autowired
    EntityManager em;
    
    public void example() {
        // 엔티티 매니저가 엔티티를 관리하지 않는 상태(비영속 상태)
        Member member = new Member(1L, "홍길동");
        
        // 엔티티가 관리되는 상태
        em.persist(member);
        
        // 엔티티 객체가 분리된 상태
        em.detach(member);
        // 엔티티 객체가 삭제된 상태
        em.remove(member);
    }
}
        
```



엔티티를 처음 만들면 엔티티는 비영속 상태가 됩니다.

persist() 메서드를 사용해 엔티티를 관리 상태로 만들 수 있으며,

Member 객체는 영속성 컨텍스트에서 상태가 관리됩니다.

만약 엔티티를 영속성 컨텍스트에서 관리하고 싶지 않다면 detach() 메서드를 사용해 분리 상태로 만들수 있습니다.

또한 더이상 객체가 필요없다면 remove() 메서드를 사용해서 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제할 수 있습니다.



## 스프링 데이터 JPA에서 제공하는 메서드 사용해보기

```java
@Service
public class MemberService {
    
    @Autowired
    MemberRepository memberRepository;
    
    public void test() {
        memberRepository.save(new Member(1L, "A"));
        
        // 조회
        Optional<Member> member = memberRepository.findById(1L);
        List<Member> allMembers = memberRepository.findAll();
        // 삭제
        memberRepository.deleteById(1L);
    }
}
```

<figure><img src=".gitbook/assets/스크린샷 2023-12-09 오후 10.26.12.png" alt=""><figcaption></figcaption></figure>

엔티티(Entity), 엔티티 매니저(Entity Manager), 및 엔티티 매니저 팩토리(Entity Manager Factory)는 JPA(Java Persistence API)와 같은 ORM(Object-Relational Mapping) 프레임워크에서 사용되는 핵심 개념들입니다. 이들은 데이터베이스와 객체 지향 프로그래밍 언어 사이의 상호작용을 관리하는 데 중요한 역할을 합니다.

#### 1. 엔티티 (Entity)

엔티티는 데이터베이스 테이블의 행(row)에 해당하는 데이터를 객체 지향 방식으로 표현한 것입니다. 엔티티는 보통 클래스로 정의되며, 클래스의 인스턴스는 테이블의 특정 행에 해당합니다. 각 엔티티는 고유한 식별자(Primary Key)를 가지며, 이를 통해 구별됩니다.

* **특징**: 데이터베이스의 테이블과 매핑되어 객체 지향적인 데이터 관리를 가능하게 합니다.
* **사용**: CRUD(Create, Read, Update, Delete) 작업을 위해 사용됩니다.

#### 2. 엔티티 매니저 (Entity Manager)

엔티티 매니저는 엔티티와 데이터베이스 간의 상호작용을 관리하는 객체입니다. 이는 엔티티의 생명주기를 관리하며, 데이터베이스 작업을 수행하는 주체입니다.

* **역할**: 엔티티의 조회, 저장, 업데이트, 삭제 등의 작업을 관리합니다.
* **영속성 컨텍스트**: 엔티티 매니저는 내부적으로 영속성 컨텍스트를 사용하여 엔티티의 상태를 관리하고, 변경 감지, 지연 로딩 등의 기능을 제공합니다.

#### 3. 엔티티 매니저 팩토리 (Entity Manager Factory)

엔티티 매니저 팩토리는 엔티티 매니저 객체를 생성하는 공장 역할을 합니다. 애플리케이션에서는 일반적으로 하나의 엔티티 매니저 팩토리만 생성하고, 이를 통해 필요할 때마다 엔티티 매니저를 생성합니다.

* **생성**: 보통 애플리케이션의 시작 시점에 생성됩니다.
* **역할**: 필요에 따라 엔티티 매니저 인스턴스를 생성하고 제공합니다.

엔티티 매니저 팩토리와 엔티티 매니저의 관계는 공장(Factory)과 생성된 제품(엔티티 매니저)의 관계로 이해할 수 있습니다. 엔티티 매니저 팩토리는 비용이 많이 드는 객체이므로 애플리케이션 전반에서 한 번만 생성하고 재사용하는 것이 좋습니다. 반면, 엔티티 매니저는 상대적으로 가볍고, 각각의 트랜잭션이나 요청마다 새로 생성하여 사용하는 것이 일반적입니다.



